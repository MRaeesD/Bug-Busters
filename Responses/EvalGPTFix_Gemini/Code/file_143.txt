import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.Collections;
    import java.util.HashMap;
    import java.util.HashSet;
    import java.util.List;
    import java.util.Map;
    import java.util.Scanner;
    import java.util.Set;
    
    
    public class Main {
    	
    	public static void main(String[] args) {
    		Scanner scanner = new Scanner(System.in);
    		
    		int n = Integer.parseInt(scanner.next());
    		int[][] a = new int[n][n];
    		int[][] b = new int[n][n];
    		for(int i=0; i<n*2; i++) {
    			for(int k=0; k<n; k++) {
    				if(i < n) {
    					a[i][k] = Integer.parseInt(scanner.next());
    				}else {
    					b[i-n][k] = Integer.parseInt(scanner.next());
    				}
    			}
    		}
    		
    		int[][] tmp = new int[n][n];
    		
    		boolean flag = false; // Start with false, assume no match initially
    		for(int kaiten = 0; kaiten<4; kaiten++) {
    			
    			for(int i=0; i<n; i++) {
    				for(int k=0; k<n; k++) {		
    					
    					tmp[k][i] = a[k][n-1-i]; 
    					
    				}
    			}
    			
    			flag = true; // Reset flag for each rotation
    			for(int i=0; i<n; i++) {
    				for(int k=0; k<n; k++) {
    					// Check for mismatch: '1' in rotated matrix but not in target matrix
    					if(tmp[i][k] == 1 && tmp[i][k] != b[i][k]) {
    						flag = false; 
    						break; // No need to continue checking this rotation
    					}
    				}
    				if (!flag) {
    				    break; // No need to continue to the next row in this rotation
    				}
    			}
    			if(flag) { // If the flag remains true after all checks, we have a match
    				System.out.println("Yes");
    				return;
    			} 
    			
    			// If no match in this rotation, copy tmp back to 'a' for the next rotation
    			for(int i=0; i<n; i++) {
    				a[i] = Arrays.copyOf(tmp[i], n);
    			}
    		}
    		
    		System.out.println("No");
    	}
    }